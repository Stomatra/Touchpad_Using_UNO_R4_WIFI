# Touchpad_Using_UNO_R4_WIFI

## 作业的功能

系统界面以USB接口朝上为正方向，划分为两个核心功能区：

上半区 (240x240)：是九宫格光标控制区。
下半区 (240x80)：是三键功能操作区。

光标控制区（上半部九宫格）：此处用于控制鼠标指针的移动与拖拽操作。

八方向移动：
按住中心以外的周围 8 个格子，鼠标指针向对应方向（上、下、左、右及四个斜角）持续匀速移动，实现鼠标光标的精准定位。

拖拽锁定（圆环图标）：
位置：九宫格正中心，点击一次激活，再次点击取消。在激活状态时，中心圆环变红，模拟“按下左键不松手”；在取消状态时，中心圆环恢复默认，模拟“松开左键”。方便进行文件拖拽或框选操作，无需长时间按压物理按键。

功能操作区（下半部三键）：此处包含鼠标点击及连点器控制。

左键：普通模式：点击触发一次鼠标左键单击。连点模式：点击激活左键连点，按键常亮；再次点击停止连点，按键熄灭。

右键：普通模式：点击触发一次鼠标右键单击。连点模式：同左键。

左键连点与右键连点互斥，开启一方会自动关闭另一方。

模式切换键 (Δ）：

位置：下方正中间，点击循环切换连点速度模式。

指示灯反馈（Δ）：

在不同状态下会变色：

1.  无色/灭灯：普通模式，无连点；
2.  绿色：低速连点，1次/秒；
3.  黄色：中速连点，5次/秒；
4.  红色：高速连点，10次/秒。

## 作业的实现

为了解决闪存空间有限的问题，项目弃用了传统的位图加载方案，转而采用代码矢量绘制技术。实现原理：利用 Adafruit_GFX 图形库，实时计算并绘制界面。

锐利箭头算法：为了获得美观的指向箭头，程序引入了 <math.h> 库，通过三角函数（sin/cos）计算箭头尖端与尾部的精确坐标，动态生成锐利的三角形，而非简单的像素堆叠。优势：相比图片方案，节省了约 98% 的存储空间，且由 GPU/CPU 直接指令绘制，刷新速度极快。

触控坐标映射与校准：电阻触摸屏读取的是物理电压值，而屏幕显示使用的是像素坐标。两者之间存在非线性和方向差异。映射算法：使用线性插值函数 map() 将物理值转换为逻辑值。

镜像与翻转修正：针对屏幕USB 接口朝上的握持习惯，程序在算法层对坐标进行了数学变换。

区域判定逻辑：

程序通过网格化算法处理用户的触摸意图，避免了复杂的碰撞检测。
九宫格判定：将 X 坐标整除 80 (x / 80)，Y 坐标整除 80 (y / 80)，直接得出用户点击的是第几行、第几列的格子。
功能分流：若 Y < 240：判定为光标移动区，执行 Mouse.move()；若 Y >= 240：判定为功能按键区，执行点击或模式切换。

智能连点器，新计时方案：

为了保证在连点鼠标的同时，用户依然能流畅地操作触摸屏，程序采用了新的计时逻辑。
传统误区：使用 delay() 函数会暂停整个单片机，导致触摸失灵。
实现：基于 millis() ，程序在主循环 loop() 中不断轮询当前时间，当 (当前时间 - 上次点击时间) > 设定间隔 时，触发一次鼠标点击。
状态机设计：使用枚举类型管理 1CPS, 5CPS, 10CPS 三种速度模式，实现点击一次 M 键即可循环切换频率。

拖拽锁定：

模拟了人手“按住左键不放”的物理动作。
逻辑实现：设置一个布尔变量 isDragLocked。
激活时：调用 Mouse.press(MOUSE_LEFT)，发送按下指令但不发送松开指令。
取消时：调用 Mouse.release(MOUSE_LEFT)，发送松开指令。
视觉反馈：通过改变中心圆环的状态，让用户直观看到当前是否处于“拖拽中”。

状态反馈系统：

为了提升人机交互体验，系统在每一个操作环节都加入了视觉反馈。
即时高亮：当手指按下下方功能键时，利用 fillRect 函数瞬间反转按键背景色，模拟物理按键的下压感。
模式指示：在界面特定区域（如三角形内部、状态条），根据当前连点速度填充绿/黄/红等不同颜色，使用户很方便地知晓当前工作模式。
